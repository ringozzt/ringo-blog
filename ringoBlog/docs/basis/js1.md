# JavaScript 编程基础

## JS 的内存空间分为栈、堆、池

其中栈存放**变量**，堆存放**对象**，池存放**常量**，所以也叫常量池

## 栈

栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈是一种**先进后出**的结构，为了获得栈底的元素，必须拿掉上面的元素。

## 堆

一种排序过的树状结构，我们说的堆，通常指二叉堆，必须是完全二叉树(近似满二叉树)。堆的特点是根节点值是整个树中的最值（大顶堆/小顶堆）

堆经常被用来实现优先队列，这种结构优势是可以动态分配内存大小，缺点是运行时需动态分配内存，存取速度较慢

## 数据类型

### 基本数据类型

String、Number、Boolean、null、undefined、Symbol

保存在栈内存中，因为占用空间小、大小固定，频繁被使用

- 产生闭包的变量会被存放在堆中，因为栈在上下文执行完毕后会被 GC，堆不会。由 JS 引擎**逃逸分析**出变量应该存在哪种结构中。

### 引用数据类型

Object、Array、Function...

存储在堆内存

- 占据空间大、大小不确定
- 引用数据类型在栈中存储了指针，指向堆内该实体的起始地址
- Js 解释器寻找引用值时，会先检索栈中的地址，再获得堆中的实体

## 变量复制

- 基本数据类型直接拷贝一份

- 引用数据类型相当于多了一个地址指针，实际指向同一个对象

## Js 创建对象

- new 关键字执行构造函数
- 对象字面量

## Js 的作用域链及背后的知识体系

### 作用域不等于执行上下文

JavaScript 属于解释型语言，他的执行分为解释和执行两个阶段

**解释阶段**：

- 词法分析
- 语法分析
- 作用域规则确定

**执行阶段**：

- 创建执行上下文
- 执行函数
- 垃圾回收

> JavaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。

作用域和执行上下文之间最大的区别是： **执行上下文(EC)在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变**。

一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。**同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值**。

作用域决定了代码块中变量和方法的可见性。

### 作用域链

当前作用域下没有定义的变量，变成自由变量。自由变量会到父级作用域（\*实际上是自由变量**所在的函数**被**创建**时的作用域中)查找，一层一层向上，直到找到全局作用域还是没找到，就宣布放弃(undefined)。

```javascript
var x = 10;
function fn() {
  console.log(x);
}
function show(f) {
  var x = 20(function () {
    f(); //10，而不是20
  })();
}
show(fn);
```

### 全局作用域

#### 初始化全局对象

- js 引擎在执行代码之前，会在堆内存中创建一个全局对象，Global Object(GO)
- **所有作用域** 都可以访问该对象
- 里面会自带一些工具函数，date、setTimeout、Infinity 等等
- 包含一个指向自己的 window 属性

#### 执行上下文栈 ECS(调用栈)

- js 引擎内部有一个 ECS，用于执行代码的调用栈。全局 EC 中，变量对象(VO)就是 GO

- 全局的代码会先构建一个全局执行上下文(GEC)

- GEC 会被压入 ECS 中执行

  - 步骤一：parse 转换成 AST 的过程中，将全局定义的变量、函数加到 GO 中，但是不会赋值。

    这就是变量的作用域提升

  - 步骤二：在代码的执行过程中，该赋值的赋值，该执行的执行

### 函数作用域

- 在执行一个函数时，会根据函数体创建一个函数执行上下文(FEC)，压入 ECS。包含以下三部分

  - 在解析成 AST 时，会创建活跃对象(AO)

    AO 中包含形参、arguments、函数定义和指向函数的对象、变量

  - **作用域链**:由 VO(在函数中就是 AO 对象)和父级 VO 组成，一层一层向外查找

  - this 绑定的值。优先级由高到低

    - new 绑定
    - 显式绑定(call(obj, ...args)、apply(obj, [args])、bind(obj, ...args)非立即执行)
    - 隐式绑定(由对象发起的调用)
    - 默认绑定(独立函数调用)

### 块级作用域

- ES5 中只有函数作用域、全局作用域。实际上 ES6 之后出现了块级作用域，可用 let、const 生成。而且前面提到的变量对象 VO 改名了，现在叫变量环境 VE

- 两种创建方式

  - 在一个函数内部，function、箭头函数
  - 在一个花括号内部

- 块级作用域中声明变量不会提升到代码块顶部
- 禁止重复声明
- 避免了 for 循环中使用延时函数产生闭包导致的 bug，绑定块级作用域形成父子作用域解决
