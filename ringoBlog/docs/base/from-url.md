# 输入 url 到页面渲染发生了什么

## URL 解析

为什么需要 URL 编码：

URL 编码的原则就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符，从而形成统一标准。

### encodeURIComponent 和 encodeURI

escape 是对字符串进行编码，不适用于 URL

> escape 函数是全局对象的属性。特色字符如: @\*\_+-./ 被排除在外。字符的 16 进制格式值,当该值小于等于 0xFF 时,用一个 2 位转移序列: %xx 表示. 大于的话则使用 4 位序列:%uxxxx 表示.

#### encodeURIComponent 编码范围更大

encodeURI 方法不会对下列字符编码：

```
ASCII字母，数字，~!@#$&*()=:/,;?+'
```

encodeURIComponent 方法不会对下列字符编码：

```
ASCII字母，数字， ~!*()'
```

**1、如果只是编码字符串，不和 URL 有半毛钱关系，那么用 escape。**

**2、如果你需要编码整个 URL，然后需要使用这个 URL，那么用 encodeURI。**

比如

```js
encodeURI('https://www.baidu.com/some other thing');

// 编码后会变为
('https://www.baidu.com/some%20other%20thing');

// 其中，空格被编码成了%20。
// 但是如果你用了encodeURIComponent，那么结果变为

('http%3A%2F%2Fwww.baidu.com%2Fsome%20other%20thing');

// 连 "/" 都被编码了，整个URL已经没法用了。
```

**3、当你需要编码 URL 中的参数(包括"/")的时候，那么 encodeURIComponent 是最好方法。**

### URL、URN、URI

`URN`和`URL`都已经是`URI`的一种。

- `URI` 统一资源标志符，在某一规则下能把一个资源独一无二地标识出来，是 URL 和 URN 的超集。

  相当于身份证号码。

- `URL` 统一资源定位符，主要由 `协议`、`主机`、`端口`、`路径`、`查询参数`、`锚点`6 部分组成。

  相当于家庭住址。

- `URN` 统一资源名称， `URN`是`URI`的历史名字，只从`URI`发布之后，`URN`的使用已经被`URI`取代了。

  相当于姓名。

<img src="https://cdn.jsdelivr.net/gh/ringozzt/myPics@main/uri.png" alt="URI示意图" style="zoom: 33%;" />

### 输入 URL 后，浏览器会解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。

- 浏览器发送请求前，根据请求头的`expires`和`cache-control`判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。

- 没有命中强缓存规则，浏览器会发送请求，根据请求头的`If-Modified-Since`和`If-None-Match`判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。

- 如果前两步都没有命中，则进入下一步**从服务端获取资源**。

## DNS 域名解析

在发起 http 请求之前，浏览器首先要去获得我们想访问网页的 IP 地址，浏览器会发送一个 UDP 的包给 DNS 域名解析服务器。

### 解析过程：

<img src="https://cdn.jsdelivr.net/gh/ringozzt/myPics@main/dns.awebp" style="zoom: 50%;" />

#### 递归查询

我们的浏览器、操作系统、路由器都会缓存一些 URL 对应的 IP 地址，统称为 DNS 高速缓存。这是为了加快 DNS 解析速度，使得不必每次都到根域名服务器中去查询。

#### 迭代查询

局部的 DNS 服务器并不会自己向其他服务器进行查询，而是把能够解析该域名的服务器 IP 地址返回给客户端，客户端会不断的向这些服务器进行查询，直到查询到了位置，迭代的话只会帮你找到相关的服务器，然后说我现在比较忙，你自己去找吧。

- 查找本地 hosts 文件

> 下面 2 步是递归

- DNS 域名解析器（电脑里配置的）

> 下面 4 步为迭代查询

- 本地的 DNS 服务器有没有缓存（一般是电信、联通等运营商）
- 如果没有设置转发模式，根域名服务器(返回 com 地址)
- 顶级域名服务器.com/.cn/.edu(返回 baidu.com 地址)
- 权威域名服务器.taobao/.baidu(返回www.baidu.com)

#### 递归、迭代定义

##### 递归：程序重复调用自身，并明确有递归结束条件的编程称为递归。

使用要满足以下两个条件：

- 在过程或函数内调用自身；
- 必须有一个明确的递归结束条件；

#### 迭代：迭代是重复反馈过程的活动。每一次对过程的重复称为一次“迭代”，每一次迭代得到的结果会作为下一次迭代的初始值。

#### 两者的关系：

1. 递归中有迭代，但迭代中不一定有递归，大部分可以相互转换；
2. 相比较而言，能用迭代就不要用递归，递归不断调用函数，浪费空间，也容易引起堆栈溢出；

**递归**：也就是函数重复调用自身，并明确有递归结束条件的编程。

**迭代**：也就是按找某种规则执行重复的活动，每一次执行的结果会作为下一次执行的初始值。

**循环**：满足条件的情况下，重复执行同一段代码。

**遍历**：按照一定的规则访问树形结构中的每一个节点，且每个节点仅访问一次。

### DNS 负载均衡

DNS 还有负载均衡的作用，现在很多网站都有多个服务器，当一个网站访问量过大的时候，如果所有请求都请求在同一个服务器上，可能服务器就会崩掉，这时候就用到了 DNS 负载均衡技术，当一个网站有多个服务器地址时，在应答 DNS 查询的时候，DNS 服务器会对每个查询返回不同的解析结果，也就是返回不同的 IP 地址，从而把访问引导到不同的服务器上去，来达到负载均衡的目的。例如可以根据每台机器的负载量，或者该机器距离用户的地理位置距离等等条件。

#### DNS 预解析

大型网站，有多个不同服务器资源的情况下，都可采取 DNS 预解析，提前解析，减少页面卡顿。

```javascript
<link rel="dns-prefetch" href="www.taobao.com"
```

## TCP/IP 连接

**Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接，超过 6 个的话剩下的请求就得等待。**

<img src="https://cdn.jsdelivr.net/gh/ringozzt/myPics@main/osi-1.gif" alt="osi" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ringozzt/myPics@main/osi-2.awebp" alt="osi-2" style="zoom: 33%;" />

### 三次握手

> 为什么需要三次握手，两次不行吗？
>
> 其实这是由 TCP 的自身特点**可靠传输**决定的。客户端和服务端要进行可靠传输，那么就需要**确认双方的`接收`和`发送`能力**。第一次握手可以确认客服端的`发送能力`,第二次握手，服务端`SYN=1,Seq=Y`就确认了`发送能力`,`ACK=X+1`就确认了`接收能力`,所以第三次握手才可以确认客户端的`接收能力`。不然容易出现丢包的现象。

#### 三次握手过程中可以携带数据吗？

其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据。

为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。

#### 什么是半连接队列？

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

这里在补充一点关于 SYN-ACK 重传次数的问题： 服务器发送完 SYN-ACK 包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s...

#### ISN 是固定的吗？

当一端为建立连接而发送它的 SYN 时，它为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。ISN 可以看作是一个 32 比特的计数器，每 4ms 加 1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。

三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

#### SYN 攻击

服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```sh
netstat -n -p TCP | grep SYN_RECV
```

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护

### 发送 HTTP 请求

这里又分为 HTTP0.9、HTTP1.0、HTTP1.1、HTTP2、HTTP3

### HTTP 发展历史

#### HTTP/0.9

- 只有一个命令 GET
- 响应类型: 仅 超文本
- 没有 header 等描述数据的信息
- 服务器发送完毕，就关闭 TCP 连接

#### HTTP/1.0

- 增加了很多命令（post HESD ）
- 增加`status code` 和 `header`
- 多字符集支持、多部分发送、权限、缓存等
- 响应：不再只限于超文本 (Content-Type 头部提供了传输 HTML 之外文件的能力 — 如脚本、样式或媒体文件)

#### HTTP/1.1

- 持久连接。TCP 三次握手会在任何连接被建立之前发生一次。最终，当发送了所有数据之后，服务器发送一个消息，表示不会再有更多数据向客户端发送了；则客户端才会关闭连接（断开 TCP）
- 支持的方法: `GET` , `HEAD` , `POST` , `PUT` ,`DELETE` , `TRACE` , `OPTIONS`
- 进行了重大的性能优化和特性增强，分块传输、压缩/解压、内容缓存磋商、虚拟主机（有单个 IP 地址的主机具有多个域名）、更快的响应，以及通过增加缓存节省了更多的带宽

#### HTTP2

- 所有数据以二进制传输。HTTP1.x 是基于文本的，无法保证健壮性，HTTP2.0 绝对使用新的二进制格式，方便且健壮
- 同一个连接里面发送多个请求不再需要按照顺序来
- 头信息压缩以及推送等提高效率的功能

#### HTTP3

- QUIC“快速 UDP 互联网连接”（Quick UDP Internet Connections）

HTTP3 的主要改进在传输层上。传输层不会再有我前面提到的那些繁重的 TCP 连接了。现在，一切都会走 UDP。

### HTTP 协议特点

1. 支持客户/服务器模式。
2. 简单快速客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
3. 灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type（Content-Type 是 HTTP 包中用来表示内容类型的标识）加以标记。
4. 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5. 无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

### 各协议与 HTTP 协议关系

- DNS 服务：解析域名至对应的 IP 地址
- HTTP 协议：生成针对目标 Web 服务器的 HTTP 请求报文
- TCP 协议：将请求报文按序号分割成多个报文段
- IP 协议：搜索对方的地址，一边中转一边传送
- TCP 协议：按序号以原来的顺序重组请求报文请求的处理结果也同样利用 TCP/IP 协议向用户进行回传

> - TCP 是底层通讯协议，定义的是数据传输和连接方式的规范；

- HTTP 是应用层协议，定义的是传输数据的内容的规范；
- HTTP 协议中的数据是利用 TCP 协议传输的，所以支持 HTTP 也就一定支持 TCP。

### HTTPS

在 HTTP 的基础上再加一层 TLS（传输层安全性协议）或者 SSL（安全套接层），就构成了 HTTPS 协议。

HTTPS 默认工作在 TCP 协议 443 端口，它的工作流程一般如以下方式：

1. TCP 三次同步握手
2. 客户端验证服务器数字证书
3. DH 算法协商对称加密算法的密钥、hash 算法的密钥
4. SSL 安全加密隧道协商完成
5. 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的 hash 算法进行数据完整性保护，保证数据不被篡改。

<img src="https://cdn.jsdelivr.net/gh/ringozzt/myPics@main/TSL握手.awebp" style="zoom:67%;" />

### 服务器端：处理请求并返回 HTTP 报文

每台服务器上都会安装处理请求的应用——Web Server。常见的 Web Server 产品有 `apache`、`nginx`、`IIS` 或 `Lighttpd` 等。

HTTP 请求一般可以分为两类，静态资源 和 动态资源。

请求访问静态资源，这个就直接根据 url 地址去服务器里找就好了。

请求动态资源的话，就需要 web server 把不同请求，委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应，发送到客户端。

服务器在处理请求的时候主要有三种方式：

- 第一种：是用一个线程来处理所有的请求，并且同时只能处理一个请求，但是这样的话性能是非常的低的。
- 第二种：是每一个请求都给他分配一个线程但是当链接和请求比较多的时候就会导致服务器的 cpu 不堪重负。
- 第三种：就是采用复用 I/O 的方式来处理例如通过 epoll 方式监视所有链接当链接状态发生改变的时候才去分配空间进行处理。

#### 响应完成之后

**怎么办？TCP 连接就断开了吗？**

不一定。这时候要判断`Connection`字段, 如果请求头或响应头中包含**Connection: Keep-Alive**，表示建立了持久连接，这样`TCP`连接会一直保持，之后请求统一站点的资源会复用这个连接。

否则断开`TCP`连接, 请求-响应流程结束。

## 浏览器解析阶段

完成了网络请求和响应，如果响应头中`Content-Type`的值是`text/html`，那么接下来就是浏览器的`解析`和`渲染`工作了。

首先来介绍解析部分，主要分为以下几个步骤:

- 构建 `DOM`树、`CSS 对象模型` (`CSSOM`)
- `样式`计算
- 生成`布局树`(`Layout Tree`)

### 构建 `DOM` 树

由于浏览器无法直接理解`HTML字符串`，因此将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是`DOM树`。`DOM树`本质上是一个以`document`为根节点的多叉树。

解析 HTML 的过程涉及到编译原理中的一些概念，在此不做展开。抛出一些结论：

- HTML 的文法并不是`上下文无关文法`。
- HTML5 [规范](https://link.juejin.cn/?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fparsing.html)详细地介绍了解析算法。这个算法分为两个阶段:

  1. 标记化。
  2. 建树。

-

### 样式计算生成 `CSSOM`

关于 CSS 样式，它的来源一般是三种:

1. **link 标签引用**
2. **style 标签中的样式**
3. **元素的内嵌 style 属性**

#### 格式化样式表

首先，浏览器是无法直接识别 CSS 样式文本的，因此渲染引擎接收到 CSS 文本之后第一件事情就是将其转化为一个结构化的对象，即 styleSheets。

这个格式化的过程过于复杂，而且对于不同的浏览器会有不同的优化策略，这里就不展开了。

在浏览器控制台能够通过`document.styleSheets`来查看这个最终的结构。当然，这个结构包含了以上三种 CSS 来源，为后面的样式操作提供了基础。

#### 计算每个节点的具体样式

样式已经被`格式化`和`标准化`,接下来就可以计算每个节点的具体样式信息了。

其实计算的方式也并不复杂，主要就是两个规则: **继承**和**层叠**。

每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫`UserAgent样式`。这就是继承规则，非常容易理解。

然后是层叠规则，CSS 最大的特点在于它的层叠性，也就是最终的样式取决于各个属性共同作用的效果，许多人也是苦恼于他的非正交性。

> 怎么学好这种不正交的语言？
> 有一个办法：试。
> 你试的组合情况越多，就越能了解各种奇怪的现象。
> 其实不用那么悲观，常用的组合也就几十种吧，都试出来并记下来就行了。
>
> 或者：
>
> 学习 CSS3 中完备、正交的 Flex，缺点是低版本浏览器不兼容

在计算完样式之后，所有的样式值会被挂在到`window.getComputedStyle`当中，也就是可以通过 JS 来获取计算后的样式，非常方便。

### 布局树`Layout Tree`

现在已经生成了`DOM树`和`CSSOM`，接下来要做的就是通过浏览器的布局系统`确定元素的位置`，也就是要生成一棵`布局树`(Layout Tree)。

1. DOM 树与 CSSOM 树合并后形成渲染树。
2. 渲染树只包含渲染网页所需的节点。
3. 布局计算每个对象的精确位置和大小。
4. 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。

实际上生成`Render Tree`渲染树这种说法已经是 16 年之前的事情，现在 Chrome 团队已经做了大量的重构，已经没有生成`Render Tree`的过程了。而布局树的信息已经非常完善，完全拥有`Render Tree`的功能。

之所以不讲布局的细节，是因为它过于复杂，一一介绍会显得文章过于臃肿，不过大部分情况下我们只需要知道它所做的工作**是什么**即可，如果想深入其中的原理，知道它是**如何来做的**，我强烈推荐你去读一读人人 FED 团队的文章[从 Chrome 源码看浏览器如何 layout 布局](https://www.rrfed.com/2017/02/26/chrome-layout/)。

布局树生成的大致工作如下:

1. 合并 CSSOM 到 DOM 树节点
2. 遍历生成的 DOM 树节点，并把他们添加到`布局树中`。
3. 计算布局树节点的坐标位置。

## 浏览器渲染阶段

### 渲染流程：

1. 建立`图层树`(`Layer Tree`)
2. 获取 DOM 后分割为多个图层
3. 对每个图层的节点计算样式结果 （Recalculate style--样式重计算）
4. 为每个节点生成图形和位置 （reLayout--重排(回流)）
5. 将每个节点绘制填充到图层位图中 （rePaint--重绘）
6. 图层作为纹理上传至 GPU
7. 组合多个图层到页面上生成最终屏幕图像 （Composite Layers--图层重组）

### 建立图层树

如果你觉得现在`DOM节点`也有了，样式和位置信息也都有了，可以开始绘制页面了，那你就错了。

因为你忽略掉了另外一些复杂的场景，比如 3D 动画如何呈现出变换效果，当元素含有层叠上下文时如何控制显示和隐藏等等。

为了解决如上所述的问题，浏览器在构建完`布局树`之后，还会对特定的节点进行分层，构建一棵`图层树`(`Layer Tree`)。

那这棵图层树是根据什么来构建的呢？

一般情况下，节点的图层会默认属于父亲节点的图层(这些图层也称为**合成层**)。那什么时候会提升为一个单独的合成层呢？

有两种情况需要分别讨论，一种是**显式合成**，一种是**隐式合成**。

#### 显式合成

下面是`显式合成`的情况:

一、 拥有**层叠上下文**的节点。

层叠上下文也基本上是有一些特定的 CSS 属性创建的，一般有以下情况:

1. HTML 根元素本身就具有层叠上下文。
2. 普通元素设置**position 不为 static**并且**设置了 z-index 属性**，会产生层叠上下文。
3. 元素的 **opacity** 值不是 1
4. 元素的 **transform** 值不是 none
5. 元素的 **filter** 值不是 none
6. 元素的 **isolation** 值是 isolate
7. **will-change**指定的属性值为上面任意一个。(will-change 的作用后面会详细介绍)

二、需要**剪裁**的地方。

比如一个 div，你只给他设置 100 \* 100 像素的大小，而你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条会被单独提升为一个图层。

#### 隐式合成

接下来是`隐式合成`，简单来说就是`层叠等级低`的节点被提升为单独的图层之后，那么`所有层叠等级比它高`的节点**都会**成为一个单独的图层。

##### 层爆炸

这个隐式合成其实隐藏着巨大的风险，如果在一个大型应用中，当一个`z-index`比较低的元素被提升为单独图层之后，层叠在它上面的的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接让页面崩溃。这就是**层爆炸**的原理。

值得注意的是，当需要`repaint`时，只需要`repaint`本身，而不会影响到其他的层。

### 生成绘制列表

接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一个计划。

### 生成图块和生成位图

现在开始绘制操作，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫**合成线程**。

绘制列表准备好了之后，渲染进程的主线程会给`合成线程`发送`commit`消息，把绘制列表提交给合成线程。接下来就是合成线程一展宏图的时候啦。

首先，考虑到视口就这么大，当页面非常大的时候，要滑很长时间才能滑到底，如果要一口气全部绘制出来是相当浪费性能的。因此，合成线程要做的第一件事情就是将图层**分块**。这些块的大小一般不会特别大，通常是 256 _ 256 或者 512 _ 512 这个规格。这样可以大大加速页面的首屏展示。

因为后面图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个**低分辨率**的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。

顺便提醒一点，渲染进程中专门维护了一个**栅格化线程池**，专门负责把**图块**转换为**位图数据**。

然后合成线程会选择视口附近的**图块**，把它交给**栅格化线程池**生成位图。

生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给`合成线程`。

### 显示器显示内容

栅格化操作完成后，**合成线程**会生成一个绘制命令，即"DrawQuad"，并发送给浏览器进程。

浏览器进程中的`viz组件`接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。为什么发给显卡呢？我想有必要先聊一聊显示器显示图像的原理。

无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的**前缓冲区**。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到**后缓冲区**，然后系统自动将`前缓冲区`和`后缓冲区`对换位置，如此循环更新。

看到这里你也就是明白，当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。

### 重绘重排

#### 引起重排的事件：

1. 页面首次渲染
2. 浏览器窗口大小发生改变
3. 元素尺寸或位置发生改变
4. 元素内容变化（文字数量或图片大小等等）
5. 元素字体大小变化
6. 添加或者删除可见的 DOM 元素
7. 激活 CSS 伪类（例如：:hover）
8. 查询某些属性或调用某些方法

#### 引起重排的属性和方法：

- clientWidth、clientHeight、clientTop、clientLeft
- offsetWidth、offsetHeight、offsetTop、offsetLeft
- scrollWidth、scrollHeight、scrollTop、scrollLeft
- scrollIntoView()、scrollIntoViewIffNeeded()
- getComputedStyle()
- getBoundingClientRect()
- scrollTo()

#### 如何减少回流

- css

1. 避免使用 table 布局;
2. 尽可能在 DOM 树的最末端改变 class;
3. 避免设置多层内联样式;
4. 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上;
5. 避免使用 CSS 表达式（例如：calc()）。

- JS

1. 避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。
2. 避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。
3. 也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。
4. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
5. 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

### 站在巨人的肩膀上学习

###### 参考文章

1. https://juejin.cn/post/6844904021308735502
2. https://zhuanlan.zhihu.com/p/86426969
3. https://www.rrfed.com/2017/02/26/chrome-layout/
4. https://juejin.cn/post/6935232082482298911
