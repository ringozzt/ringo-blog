(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{644:function(_,e,v){"use strict";v.r(e);var r=v(13),t=Object(r.a)({},(function(){var _=this,e=_.$createElement,v=_._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"模块化原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块化原理"}},[_._v("#")]),_._v(" 模块化原理")]),_._v(" "),v("h2",{attrs:{id:"esmodule-es6-模块化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#esmodule-es6-模块化"}},[_._v("#")]),_._v(" ESModule / ES6 模块化")]),_._v(" "),v("h3",{attrs:{id:"import-采用异步加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#import-采用异步加载"}},[_._v("#")]),_._v(" import 采用"),v("strong",[_._v("异步加载")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("import 模块时只是生成"),v("strong",[_._v("引用地址")]),_._v("，"),v("strong",[_._v("编译时调用")]),_._v("，也就是等到需要时才去取值，所以不存在缓存的问题")])]),_._v(" "),v("li",[v("p",[_._v("使用 import export 关键字")])]),_._v(" "),v("li",[v("p",[_._v("静态分析特性：编译阶段就分析出模块依赖")]),_._v(" "),v("blockquote",[v("p",[_._v("简单来说一段"),v("code",[_._v("js")]),_._v("代码的执行过程，需要经历以下三个步骤:")]),_._v(" "),v("ol",[v("li",[v("code",[_._v("V8")]),_._v("通过源码进行词法分析，语法分析生成"),v("code",[_._v("AST")]),_._v("和执行上下文。")]),_._v(" "),v("li",[_._v("根据"),v("code",[_._v("AST")]),_._v("生成计算机可执行的字节码。")]),_._v(" "),v("li",[_._v("执行生成的字节码。")])]),_._v(" "),v("p",[_._v("ESM 在第一步时就可以确定依赖关系，从而剔除 dead code（Terser 根据 DCE 标记删掉这些没被用到的导出语句）；\n而 CommonJS 同步加载模块，依赖于代码的执行，第三步才能确认模块依赖，所以不支持 Tree-Shaking。")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://mp.weixin.qq.com/s/igLFmFGQXSq0qb56-mr0CQ",target:"_blank",rel:"noopener noreferrer"}},[_._v("从 Tree Shaking 来走进 Babel 插件开发"),v("OutboundLink")],1)])])]),_._v(" "),v("li",[v("p",[_._v("一个模块要暴露或引入的方法能够在编译阶段就确定")])]),_._v(" "),v("li",[v("p",[_._v("有利于 webpack 分析模块依赖，没用到的方法从 bundle 中剔除")])]),_._v(" "),v("li",[v("p",[_._v("tree-shaking 依赖于 ES Module 的静态语法分析(不执行任何代码就可以知道模块间的依赖关系)")])]),_._v(" "),v("li",[v("p",[_._v("自动采用严格模式")])]),_._v(" "),v("li",[v("p",[_._v("import 静态编译")]),_._v(" "),v("blockquote",[v("p",[_._v("虽然 import 命令具有提升效果，会提升到整个模块的头部， 但为了规范还是建议放在文件开头。")])])])]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"commonjs-cjs"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-cjs"}},[_._v("#")]),_._v(" commonJs / CJS")]),_._v(" "),v("h3",{attrs:{id:"cjs-加载模块是同步的-加载完毕才能运行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cjs-加载模块是同步的-加载完毕才能运行"}},[_._v("#")]),_._v(" cjs 加载模块是"),v("strong",[_._v("同步")]),_._v("的，加载完毕才能运行")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("Node 遵循 cjs 规范实现了模块化")])]),_._v(" "),v("li",[v("p",[_._v("导出 exports module.exports 导入 require")])]),_._v(" "),v("li",[v("p",[_._v("exports 是一个对象，可以在这个对象中添加属性")])]),_._v(" "),v("li",[v("p",[_._v("module.exports = exports = { }同一块内存")]),_._v(" "),v("blockquote",[v("p",[_._v("cjs 中没有 module.exports 这个概念，但是为了实现模块的导出，node 中使用的是 module 的类，每一个模块都是 module 的一个实例，所以 node 中导出的其实是 module.exports，exports 只是辅助")])])]),_._v(" "),v("li",[v("p",[_._v("所以浏览器使用 AMD，后来是 ESM")])]),_._v(" "),v("li",[v("p",[_._v("另一方面 webpack 可以将 cjs esm 转换成 umd")])]),_._v(" "),v("li",[v("p",[_._v("node 会缓存 require 引入，不会有重复引入的问题")])]),_._v(" "),v("li",[v("p",[_._v("cjs 加载的就是 module.exports")])]),_._v(" "),v("li",[v("p",[_._v("node 中采用 dfs 处理循环引入")])])]),_._v(" "),v("h3",{attrs:{id:"require-动态编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#require-动态编译"}},[_._v("#")]),_._v(" require 动态编译")]),_._v(" "),v("p",[_._v("第一次加载某个模块时， Node 会缓存该模块， 后续加载就从缓存中获取。")]),_._v(" "),v("p",[_._v("require 是值拷贝，"),v("strong",[_._v("运行时调用")]),_._v("，也就是"),v("strong",[_._v("同步加载")]),_._v("。")]),_._v(" "),v("p",[_._v("相当于一个全局方法，所以 require 理论上可以写在代码块的任何地方。")]),_._v(" "),v("h4",{attrs:{id:"require-和-import-的性能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#require-和-import-的性能"}},[_._v("#")]),_._v(" require 和 import 的性能")]),_._v(" "),v("p",[v("code",[_._v("require")]),_._v(" 的性能相对于 "),v("code",[_._v("import")]),_._v(" 稍低。")]),_._v(" "),v("p",[_._v("因为 "),v("code",[_._v("require")]),_._v(" 是在运行时才引入模块并且还赋值给某个变量，而 "),v("code",[_._v("import")]),_._v(" 只需要依据 "),v("code",[_._v("import")]),_._v(" 中的接口在编译时引入指定模块所以性能稍高")]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"umd"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#umd"}},[_._v("#")]),_._v(" UMD")]),_._v(" "),v("ul",[v("li",[_._v("最通用的 js 模块化格式，在前端和后端都适用")]),_._v(" "),v("li",[_._v("兼容 cjs 和 amd 的模块，既可以在 webpack、node 中被 require 引用，也可以在浏览器中直接用 cdn 引入")]),_._v(" "),v("li",[_._v("部分 npm 包会打出 cjs、esm、umd 三种格式，如 antd")]),_._v(" "),v("li",[_._v("当使用 Rollup/Webpack 之类的打包器时，UMD 通常用作备用模块")])]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"amd"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#amd"}},[_._v("#")]),_._v(" AMD")]),_._v(" "),v("ul",[v("li",[_._v("异步模块定义")]),_._v(" "),v("li",[_._v("采用异步加载模块")]),_._v(" "),v("li",[_._v("早于 cjs，但 cjs 还在使用，amd 已经逐渐淘汰了")]),_._v(" "),v("li",[_._v("一开始被提议的时候，AMD 是为前端而做的(而 CJS 是后端)")])]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"cmd"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cmd"}},[_._v("#")]),_._v(" CMD")]),_._v(" "),v("ul",[v("li",[_._v("普通模块定义")]),_._v(" "),v("li",[_._v("异步加载模块，吸收了 cjs 的优点，但目前也较少使用了")]),_._v(" "),v("li",[_._v("优秀的实现方案： sea.js")])])])}),[],!1,null,null,null);e.default=t.exports}}]);