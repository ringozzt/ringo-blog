(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{641:function(_,v,e){"use strict";e.r(v);var r=e(13),t=Object(r.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"https-演进过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#https-演进过程"}},[_._v("#")]),_._v(" HTTPS 演进过程")]),_._v(" "),e("p",[e("code",[_._v("HTTP")]),_._v("的特性是明文传输，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改，具体来说，HTTP 数据经过 TCP 层，然后经过"),e("code",[_._v("WIFI路由器")]),_._v("、"),e("code",[_._v("运营商")]),_._v("和"),e("code",[_._v("目标服务器")]),_._v("，这些环节中都可能被中间人拿到数据并进行篡改，也就是我们常说的"),e("strong",[_._v("中间人攻击")]),_._v("。")]),_._v(" "),e("p",[_._v("那如何进一步保证安全性呢？")]),_._v(" "),e("p",[_._v("首先要介绍下传统的 TLS 握手，对称加密、非对称加密以及"),e("strong",[_._v("更安全的加解密过程")]),_._v("。")]),_._v(" "),e("h2",{attrs:{id:"对称加密和非对称加密"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对称加密和非对称加密"}},[_._v("#")]),_._v(" 对称加密和非对称加密")]),_._v(" "),e("h3",{attrs:{id:"概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[_._v("#")]),_._v(" 概念")]),_._v(" "),e("p",[_._v("首先需要理解"),e("code",[_._v("对称加密")]),_._v("和"),e("code",[_._v("非对称加密")]),_._v("的概念，然后讨论两者应用后的效果如何。")]),_._v(" "),e("p",[e("code",[_._v("对称加密")]),_._v("是最简单的方式，指的是"),e("code",[_._v("加密")]),_._v("和"),e("code",[_._v("解密")]),_._v("用的是"),e("strong",[_._v("同样的密钥")]),_._v("。")]),_._v(" "),e("p",[_._v("而对于"),e("code",[_._v("非对称加密")]),_._v("，如果有 A、 B 两把密钥，如果用 A 加密过的数据包只能用 B 解密，反之，如果用 B 加密过的数据包只能用 A 解密。")]),_._v(" "),e("h3",{attrs:{id:"加解密过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#加解密过程"}},[_._v("#")]),_._v(" 加解密过程")]),_._v(" "),e("p",[_._v("接着我们来谈谈"),e("code",[_._v("浏览器")]),_._v("和"),e("code",[_._v("服务器")]),_._v("进行协商加解密的过程。")]),_._v(" "),e("p",[_._v("首先，浏览器会给服务器发送一个随机数"),e("code",[_._v("client_random")]),_._v(" 和一个加密的方法列表。")]),_._v(" "),e("p",[_._v("服务器接收后给浏览器返回另一个随机数"),e("code",[_._v("server_random")]),_._v("和加密方法。")]),_._v(" "),e("p",[_._v("现在，两者拥有三样相同的凭证: "),e("code",[_._v("client_random")]),_._v("、"),e("code",[_._v("server_random")]),_._v("和加密方法。")]),_._v(" "),e("p",[_._v("接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的"),e("code",[_._v("暗号")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"各自应用的效果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#各自应用的效果"}},[_._v("#")]),_._v(" 各自应用的效果")]),_._v(" "),e("p",[_._v("如果用"),e("code",[_._v("对称加密")]),_._v("的方式，那么第三方可以在中间获取到"),e("code",[_._v("client_random")]),_._v("、"),e("code",[_._v("server_random")]),_._v("和加密方法，由于这个加密方法同时可以解密，所以中间人可以成功对暗号进行解密，拿到数据，很容易就将这种加密方式破解了。")]),_._v(" "),e("p",[_._v("那能不能只用"),e("code",[_._v("非对称加密")]),_._v("呢？理论上是可以的，但实际上非对称加密需要的计算量非常大，对于稍微大一点的数据即使用最快的处理器也非常耗时。")]),_._v(" "),e("h2",{attrs:{id:"传统-rsa-握手过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#传统-rsa-握手过程"}},[_._v("#")]),_._v(" 传统 RSA 握手过程")]),_._v(" "),e("p",[_._v("可以发现，对称加密和非对称加密，只用前者会有安全隐患，只用后者性能消耗又太大。那我们能不能把两者结合，保证性能的同时又能保证安全呢？")]),_._v(" "),e("h3",{attrs:{id:"更安全的加解密过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更安全的加解密过程"}},[_._v("#")]),_._v(" 更安全的加解密过程")]),_._v(" "),e("p",[_._v("其实是可以的，演示一下整个流程：")]),_._v(" "),e("ol",[e("li",[_._v("浏览器向服务器发送"),e("code",[_._v("client_random")]),_._v("和加密方法列表。")]),_._v(" "),e("li",[_._v("服务器接收到，返回"),e("code",[_._v("server_random")]),_._v("、加密方法（选择加密方法列表中一个非对称方法）以及"),e("strong",[_._v("公钥")]),_._v("。")]),_._v(" "),e("li",[_._v("浏览器接收，接着生成另一个随机数"),e("code",[_._v("pre_random")]),_._v(", 并且用"),e("strong",[_._v("公钥")]),_._v("加密，传给服务器。(敲黑板！重点操作！)")]),_._v(" "),e("li",[_._v("服务器用"),e("strong",[_._v("私钥")]),_._v("解密这个被加密后的"),e("code",[_._v("pre_random")]),_._v("。")])]),_._v(" "),e("p",[_._v("现在浏览器和服务器有三样相同的凭证:"),e("code",[_._v("client_random")]),_._v("、"),e("code",[_._v("server_random")]),_._v("和"),e("code",[_._v("pre_random")]),_._v("。然后两者用相同的加密方法混合这三个随机数，生成最终的"),e("code",[_._v("密钥")]),_._v("（对称加密用）。")]),_._v(" "),e("p",[_._v("然后浏览器和服务器尽管用一样的密钥进行通信，即使用"),e("code",[_._v("对称加密")]),_._v("。")]),_._v(" "),e("p",[_._v("这个最终的密钥是很难被中间人拿到的，为什么呢? 因为中间人没有私钥（一直在服务端手里），从而"),e("strong",[_._v("拿不到 pre_random")]),_._v("，也就无法生成最终的密钥了。")]),_._v(" "),e("p",[_._v("回头比较一下和单纯的使用"),e("strong",[_._v("非对称加密")]),_._v(", 这种方式做了什么改进呢？本质上是"),e("strong",[_._v("防止了私钥加密的数据外传")]),_._v("。单独使用"),e("strong",[_._v("非对称加密")]),_._v("，最大的漏洞在于服务器传数据给浏览器只能用"),e("code",[_._v("私钥")]),_._v("加密，这是危险产生的根源。利用"),e("code",[_._v("对称和非对称")]),_._v("加密结合的方式，就防止了这一点，从而保证了安全。")]),_._v(" "),e("h2",{attrs:{id:"添加数字证书"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#添加数字证书"}},[_._v("#")]),_._v(" 添加数字证书")]),_._v(" "),e("p",[_._v("尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。")]),_._v(" "),e("p",[_._v("事实上"),e("code",[_._v("HTTPS")]),_._v("在上述"),e("code",[_._v("结合对称和非对称加密")]),_._v("的基础上，又添加了"),e("code",[_._v("数字证书认证")]),_._v("的步骤。其目的就是让服务器证明自己的身份。")]),_._v(" "),e("h3",{attrs:{id:"传输过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#传输过程"}},[_._v("#")]),_._v(" 传输过程")]),_._v(" "),e("p",[_._v("为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫"),e("code",[_._v("CA")]),_._v("("),e("code",[_._v("Certificate Authority")]),_._v("), 认证通过后 CA 会给服务器颁发"),e("strong",[_._v("数字证书")]),_._v("。")]),_._v(" "),e("p",[_._v("这个数字证书有两个作用:")]),_._v(" "),e("ol",[e("li",[_._v("服务器向浏览器证明自己的身份。")]),_._v(" "),e("li",[_._v("把公钥传给浏览器。")])]),_._v(" "),e("p",[_._v("这个验证的过程发生在什么时候呢？")]),_._v(" "),e("p",[_._v("当服务器传送"),e("code",[_._v("server_random")]),_._v("、加密方法的时候，顺便会带上"),e("code",[_._v("数字证书")]),_._v("(包含了"),e("code",[_._v("公钥")]),_._v("), 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。")]),_._v(" "),e("p",[_._v("现在我们来梳理一下"),e("code",[_._v("HTTPS")]),_._v("最终的加解密过程:")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ringozzt/myPics@main/Blog/TLShandle.jpg",alt:"TLS-handle-pic"}})]),_._v(" "),e("h3",{attrs:{id:"ca-认证过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ca-认证过程"}},[_._v("#")]),_._v(" CA 认证过程")]),_._v(" "),e("p",[_._v("浏览器拿到数字证书后，如何来对证书进行认证呢？")]),_._v(" "),e("p",[_._v("首先，会读取证书中的明文内容。CA 进行数字证书的签名时会保存一个 Hash 函数，来这个函数来计算明文内容得到"),e("code",[_._v("信息A")]),_._v("，然后用公钥解密明文内容得到"),e("code",[_._v("信息B")]),_._v("，两份信息做比对，一致则表示认证合法。")]),_._v(" "),e("p",[_._v("当然有时候对于浏览器而言，它不知道哪些 CA 是值得信任的，因此会继续查找 CA 的上级 CA，以同样的信息比对方式验证上级 CA 的合法性。一般根级的 CA 会内置在操作系统当中，当然如果向上找没有找到根级的 CA，那么将被视为不合法。")]),_._v(" "),e("hr"),_._v(" "),e("h2",{attrs:{id:"ssl-tls"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ssl-tls"}},[_._v("#")]),_._v(" SSL/TLS")]),_._v(" "),e("p",[_._v("理解了上面的知识，我们再来融会贯通 SSL/TLS。")]),_._v(" "),e("p",[_._v("所谓 "),e("code",[_._v("HTTPS")]),_._v("，其实它并不是一个新的协议，而是在 HTTP 下面增加了一层 SSL/TLS 协议。其原理是在"),e("code",[_._v("HTTP")]),_._v("和"),e("code",[_._v("TCP")]),_._v("之间建立了一个中间层，当"),e("code",[_._v("HTTP")]),_._v("和"),e("code",[_._v("TCP")]),_._v("通信时并不是像以前那样直接通信，直接经过了一个中间层进行加密，将加密后的数据包传给"),e("code",[_._v("TCP")]),_._v(", 响应的，"),e("code",[_._v("TCP")]),_._v("必须将数据包解密，才能传给上面的"),e("code",[_._v("HTTP")]),_._v("。这个中间层也叫"),e("code",[_._v("安全层")]),_._v("。"),e("code",[_._v("安全层")]),_._v("的核心就是对数据"),e("code",[_._v("加解密")]),_._v("。")]),_._v(" "),e("p",[_._v("简单的讲，"),e("strong",[_._v("HTTPS = HTTP + SSL/TLS")]),_._v("。")]),_._v(" "),e("p",[_._v("那什么是 SSL/TLS 呢？")]),_._v(" "),e("p",[_._v("SSL 即安全套接层（Secure Sockets Layer），在 OSI 七层模型中处于会话层(第 5 层)。之前 SSL 出过三个大版本，当它发展到第三个大版本的时候才被标准化，成为 TLS（传输层安全，Transport Layer Security），并被当做 TLS1.0 的版本，准确地说，"),e("strong",[_._v("TLS1.0 = SSL3.1")]),_._v("。")]),_._v(" "),e("p",[_._v("现在主流的版本是 TLS/1.2, 之前的 TLS1.0、TLS1.1 都被认为是不安全的，在不久的将来会被完全淘汰。因此我们接下来主要讨论的是 TLS1.2, 当然在 2018 年推出了更加优秀的 TLS1.3，大大优化了 TLS 握手过程，这个我们放在下一节再去说。")]),_._v(" "),e("p",[_._v("TLS 握手的过程比较复杂，写文章之前我查阅了大量的资料，发现对 TLS 初学者非常不友好，也有很多知识点说的含糊不清，可以说这个整理的过程是相当痛苦了。希望我下面的拆解能够帮你理解得更顺畅些吧 : ）")]),_._v(" "),e("h2",{attrs:{id:"传统-rsa-握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#传统-rsa-握手"}},[_._v("#")]),_._v(" 传统 RSA 握手")]),_._v(" "),e("p",[_._v("我们上面介绍过传统的 TLS 握手，也是大家在网上经常看到的。之所以称它为 RSA 版本，是因为它在加解密"),e("code",[_._v("pre_random")]),_._v("的时候采用的是 RSA 算法。")]),_._v(" "),e("h2",{attrs:{id:"tls-1-2-握手过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tls-1-2-握手过程"}},[_._v("#")]),_._v(" TLS 1.2 握手过程")]),_._v(" "),e("p",[_._v("现在我们来讲讲主流的 TLS 1.2 版本所采用的方式。")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ringozzt/myPics@main/Blog/TLS2.jpg",alt:"TLS1.2"}})]),_._v(" "),e("p",[_._v("刚开始你可能会比较懵，先别着急，过一遍下面的流程再来看会豁然开朗。")]),_._v(" "),e("h3",{attrs:{id:"step-1-client-hello"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#step-1-client-hello"}},[_._v("#")]),_._v(" step 1: Client Hello")]),_._v(" "),e("p",[_._v("首先，浏览器发送 client_random、TLS 版本、加密套件列表。")]),_._v(" "),e("p",[_._v("client_random 是什么？用来最终 secret 的一个参数。")]),_._v(" "),e("p",[_._v("加密套件列表是什么？我举个例子，加密套件列表一般张这样:")]),_._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("TLS_ECDHE_WITH_AES_128_GCM_SHA256\n")])])]),e("p",[_._v("意思是"),e("code",[_._v("TLS")]),_._v("握手过程中，使用"),e("code",[_._v("ECDHE")]),_._v("算法生成"),e("code",[_._v("pre_random")]),_._v("(这个数后面会介绍)，128 位的"),e("code",[_._v("AES")]),_._v("算法进行对称加密，在对称加密的过程中使用主流的"),e("code",[_._v("GCM")]),_._v("分组模式，因为对称加密中很重要的一个问题就是如何分组。最后一个是哈希摘要算法，采用"),e("code",[_._v("SHA256")]),_._v("算法。")]),_._v(" "),e("h4",{attrs:{id:"数字签名原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数字签名原理"}},[_._v("#")]),_._v(" 数字签名原理")]),_._v(" "),e("p",[_._v("其中值得解释一下的是这个"),e("strong",[_._v("哈希摘要算法")]),_._v("，试想一个这样的场景：")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("服务端现在给客户端发消息来了，客户端并不知道此时的消息到底是服务端发的，还是中间人伪造的消息。")])]),_._v(" "),e("li",[e("p",[_._v("服务端现在引入这个哈希摘要算法，将证书信息通过"),e("strong",[_._v("这个算法")]),_._v("生成一个摘要(可以理解为"),e("code",[_._v("比较短的字符串")]),_._v(")，用来"),e("strong",[_._v("标识")]),_._v("这个服务端的身份，用"),e("strong",[_._v("私钥")]),_._v("加密后把"),e("strong",[_._v("加密后的标识")]),_._v("和"),e("strong",[_._v("自己的公钥")]),_._v("传给客户端。")])]),_._v(" "),e("li",[e("p",[_._v("客户端拿到"),e("strong",[_._v("这个公钥")]),_._v("来解密，生成另外一份摘要。两个摘要进行对比，如果相同则能确认服务端的身份。")])])]),_._v(" "),e("p",[_._v("这也就是所谓"),e("strong",[_._v("数字签名")]),_._v("的原理。其中除了哈希算法，最重要的过程是"),e("strong",[_._v("私钥加密，公钥解密")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"step-2-server-hello"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#step-2-server-hello"}},[_._v("#")]),_._v(" step 2: Server Hello")]),_._v(" "),e("p",[_._v("可以看到服务器一口气给客户端回复了非常多的内容。")]),_._v(" "),e("p",[e("code",[_._v("server_random")]),_._v("也是最后生成"),e("code",[_._v("secret")]),_._v("的一个参数, 同时确认 TLS 版本、需要使用的加密套件和自己的证书，这都不难理解。那剩下的"),e("code",[_._v("server_params")]),_._v("是干嘛的呢？")]),_._v(" "),e("p",[_._v("我们先埋个伏笔，现在你只需要知道，"),e("code",[_._v("server_random")]),_._v("到达了客户端。")]),_._v(" "),e("h3",{attrs:{id:"step-3-client-验证证书-生成-secret"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#step-3-client-验证证书-生成-secret"}},[_._v("#")]),_._v(" step 3: Client 验证证书，生成 secret")]),_._v(" "),e("p",[_._v("客户端验证服务端传来的"),e("code",[_._v("证书")]),_._v("和"),e("code",[_._v("签名")]),_._v("是否通过，如果验证通过，则传递"),e("code",[_._v("client_params")]),_._v("这个参数给服务器。")]),_._v(" "),e("p",[_._v("接着客户端通过"),e("code",[_._v("ECDHE")]),_._v("算法计算出"),e("code",[_._v("pre_random")]),_._v("，其中传入两个参数:"),e("strong",[_._v("server_params")]),_._v("和"),e("strong",[_._v("client_params")]),_._v("。现在你应该清楚这个两个参数的作用了吧，由于"),e("code",[_._v("ECDHE")]),_._v("基于"),e("code",[_._v("椭圆曲线离散对数")]),_._v("，这两个参数也称作"),e("code",[_._v("椭圆曲线的公钥")]),_._v("。")]),_._v(" "),e("p",[_._v("客户端现在拥有了"),e("code",[_._v("client_random")]),_._v("、"),e("code",[_._v("server_random")]),_._v("和"),e("code",[_._v("pre_random")]),_._v("，接下来将这三个数通过一个伪随机数函数来计算出最终的"),e("code",[_._v("secret")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"step4-server-生成-secret"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#step4-server-生成-secret"}},[_._v("#")]),_._v(" step4: Server 生成 secret")]),_._v(" "),e("p",[_._v("刚刚客户端不是传了"),e("code",[_._v("client_params")]),_._v("过来了吗？")]),_._v(" "),e("p",[_._v("现在服务端开始用"),e("code",[_._v("ECDHE")]),_._v("算法生成"),e("code",[_._v("pre_random")]),_._v("，接着用和客户端同样的伪随机数函数生成最后的"),e("code",[_._v("secret")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"注意事项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[_._v("#")]),_._v(" 注意事项")]),_._v(" "),e("p",[_._v("TLS 的过程基本上讲完了，但还有两点需要注意。")]),_._v(" "),e("p",[e("strong",[_._v("第一")]),_._v("、实际上 TLS 握手是一个"),e("strong",[_._v("双向认证")]),_._v("的过程，从 step1 中可以看到，客户端有能力验证服务器的身份，那服务器能不能验证客户端的身份呢？")]),_._v(" "),e("p",[_._v("当然是可以的。具体来说，在 "),e("code",[_._v("step3")]),_._v("中，客户端传送"),e("code",[_._v("client_params")]),_._v("，实际上给服务器传一个验证消息，让服务器将相同的验证流程(哈希摘要 + 私钥加密 + 公钥解密)走一遍，确认客户端的身份。")]),_._v(" "),e("p",[e("strong",[_._v("第二")]),_._v("、当客户端生成"),e("code",[_._v("secret")]),_._v("后，会给服务端发送一个收尾的消息，告诉服务器之后的都用对称加密，对称加密的算法就用第一次约定的。服务器生成完"),e("code",[_._v("secret")]),_._v("也会向客户端发送一个收尾的消息，告诉客户端以后就直接用对称加密来通信。")]),_._v(" "),e("p",[_._v("这个收尾的消息包括两部分，一部分是"),e("code",[_._v("Change Cipher Spec")]),_._v("，意味着后面加密传输了，另一个是"),e("code",[_._v("Finished")]),_._v("消息，这个消息是对之前所有发送的数据做的"),e("strong",[_._v("摘要")]),_._v("，对摘要进行加密，让对方验证一下。")]),_._v(" "),e("p",[_._v("当双方都验证通过之后，握手才正式结束。后面的 HTTP 正式开始传输加密报文。")]),_._v(" "),e("h3",{attrs:{id:"rsa-和-ecdhe-握手的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rsa-和-ecdhe-握手的区别"}},[_._v("#")]),_._v(" RSA 和 ECDHE 握手的区别")]),_._v(" "),e("ol",[e("li",[_._v("ECDHE 握手，也就是主流的 TLS1.2 握手中，使用"),e("code",[_._v("ECDHE")]),_._v("实现"),e("code",[_._v("pre_random")]),_._v("的加密解密，没有用到 RSA。")]),_._v(" "),e("li",[_._v("使用 ECDHE 还有一个特点，就是客户端发送完收尾消息后可以提前"),e("code",[_._v("抢跑")]),_._v("，直接发送 HTTP 报文，节省了一个 RTT，不必等到收尾消息到达服务器，然后等服务器返回收尾消息给自己，直接开始发请求。这也叫"),e("code",[_._v("TLS False Start")]),_._v("。")])]),_._v(" "),e("p",[_._v("TLS 1.2 虽然存在了 10 多年，经历了无数的考验，但历史的车轮总是不断向前的，为了获得更强的安全、更优秀的性能，在"),e("code",[_._v("2018年")]),_._v("就推出了 TLS1.3，对于"),e("code",[_._v("TLS1.2")]),_._v("做了一系列的改进，主要分为这几个部分:"),e("strong",[_._v("强化安全")]),_._v("、"),e("strong",[_._v("提高性能")]),_._v("。")]),_._v(" "),e("h2",{attrs:{id:"tls-1-3-握手改进"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tls-1-3-握手改进"}},[_._v("#")]),_._v(" TLS 1.3 握手改进")]),_._v(" "),e("h3",{attrs:{id:"强化安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强化安全"}},[_._v("#")]),_._v(" 强化安全")]),_._v(" "),e("p",[_._v("在 TLS1.3 中废除了非常多的加密算法，最后只保留五个加密套件:")]),_._v(" "),e("ul",[e("li",[_._v("TLS_AES_128_GCM_SHA256")]),_._v(" "),e("li",[_._v("TLS_AES_256_GCM_SHA384")]),_._v(" "),e("li",[_._v("TLS_CHACHA20_POLY1305_SHA256")]),_._v(" "),e("li",[_._v("TLS_AES_128_GCM_SHA256")]),_._v(" "),e("li",[_._v("TLS_AES_128_GCM_8_SHA256")])]),_._v(" "),e("p",[_._v("可以看到，最后剩下的对称加密算法只有 "),e("strong",[_._v("AES")]),_._v(" 和 "),e("strong",[_._v("CHACHA20")]),_._v("，之前主流的也会这两种。分组模式也只剩下 "),e("strong",[_._v("GCM")]),_._v(" 和 "),e("strong",[_._v("POLY1305")]),_._v(", 哈希摘要算法只剩下了 "),e("strong",[_._v("SHA256")]),_._v(" 和 "),e("strong",[_._v("SHA384")]),_._v(" 了。")]),_._v(" "),e("p",[_._v("那你可能会问了, 之前"),e("code",[_._v("RSA")]),_._v("这么重要的非对称加密算法怎么不在了？")]),_._v(" "),e("p",[_._v("我觉得有两方面的原因:")]),_._v(" "),e("p",[e("strong",[_._v("第一")]),_._v("、2015 年发现了"),e("code",[_._v("FREAK")]),_._v("攻击，即已经有人发现了 RSA 的漏洞，能够进行破解了。")]),_._v(" "),e("p",[e("strong",[_._v("第二")]),_._v("、一旦私钥泄露，那么中间人可以通过私钥计算出之前所有报文的"),e("code",[_._v("secret")]),_._v("，破解之前所有的密文。")]),_._v(" "),e("p",[_._v("为什么？回到 RSA 握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成"),e("code",[_._v("pre_random")]),_._v("并用"),e("strong",[_._v("公钥")]),_._v("加密传给服务器，服务器通过"),e("strong",[_._v("私钥")]),_._v("解密，从而拿到真实的"),e("code",[_._v("pre_random")]),_._v("。当中间人拿到了服务器私钥，并且截获之前所有报文的时候，那么就能拿到"),e("code",[_._v("pre_random")]),_._v("、"),e("code",[_._v("server_random")]),_._v("和"),e("code",[_._v("client_random")]),_._v("并根据对应的随机数函数生成"),e("code",[_._v("secret")]),_._v("，也就是拿到了 TLS 最终的会话密钥，每一个历史报文都能通过这样的方式进行破解。")]),_._v(" "),e("p",[_._v("但"),e("code",[_._v("ECDHE")]),_._v("在每次握手时都会生成临时的密钥对，即使私钥被破解，之前的历史消息并不会收到影响。这种一次破解并不影响历史信息的性质也叫"),e("strong",[_._v("前向安全性")]),_._v("。")]),_._v(" "),e("p",[e("code",[_._v("RSA")]),_._v(" 算法不具备前向安全性，而 "),e("code",[_._v("ECDHE")]),_._v(" 具备，因此在 TLS1.3 中彻底取代了"),e("code",[_._v("RSA")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"提升性能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#提升性能"}},[_._v("#")]),_._v(" 提升性能")]),_._v(" "),e("h4",{attrs:{id:"握手改进"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#握手改进"}},[_._v("#")]),_._v(" 握手改进")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ringozzt/myPics@main/Blog/TLS1.3.jpg",alt:"TLS 1.3"}})]),_._v(" "),e("h4",{attrs:{id:"流程如下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流程如下"}},[_._v("#")]),_._v(" 流程如下:")]),_._v(" "),e("p",[_._v("大体的方式和 TLS1.2 差不多，不过和 TLS 1.2 相比少了一个 RTT， 服务端不必等待对方验证证书之后才拿到"),e("code",[_._v("client_params")]),_._v("，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算"),e("code",[_._v("secret")]),_._v("，节省了之前不必要的等待时间。同时，这也意味着在第一次握手的时候客户端需要传送更多的信息，一口气给传完。")]),_._v(" "),e("p",[_._v("这种 TLS 1.3 握手方式也被叫做"),e("strong",[_._v("1-RTT 握手")]),_._v("。但其实这种"),e("code",[_._v("1-RTT")]),_._v("的握手方式还是有一些优化的空间的，接下来我们来一一介绍这些优化方式。")]),_._v(" "),e("h3",{attrs:{id:"会话复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#会话复用"}},[_._v("#")]),_._v(" 会话复用")]),_._v(" "),e("p",[_._v("会话复用有两种方式: "),e("strong",[_._v("Session ID")]),_._v("和"),e("strong",[_._v("Session Ticket")]),_._v("。")]),_._v(" "),e("p",[_._v("先说说最早出现的"),e("strong",[_._v("Seesion ID")]),_._v("，具体做法是客户端和服务器首次连接后各自保存会话的 ID，并存储会话密钥，当再次连接时，客户端发送"),e("code",[_._v("ID")]),_._v("过来，服务器查找这个 ID 是否存在，如果找到了就直接复用之前的会话状态，会话密钥不用重新生成，直接用原来的那份。")]),_._v(" "),e("p",[_._v("但这种方式也存在一个弊端，就是当客户端数量庞大的时候，对服务端的存储压力非常大。")]),_._v(" "),e("p",[_._v("因而出现了第二种方式——"),e("strong",[_._v("Session Ticket")]),_._v("。它的思路就是: 服务端的压力大，那就把压力分摊给客户端呗。具体来说，双方连接成功后，服务器加密会话信息，用"),e("strong",[_._v("Session Ticket")]),_._v("消息发给客户端，让客户端保存下来。下次重连的时候，就把这个 Ticket 进行解密，验证它过没过期，如果没过期那就直接恢复之前的会话状态。")]),_._v(" "),e("p",[_._v("这种方式虽然减小了服务端的存储压力，但与带来了安全问题，即每次用一个固定的密钥来解密 Ticket 数据，一旦黑客拿到这个密钥，之前所有的历史记录也被破解了。因此为了尽量避免这样的问题，密钥需要定期进行更换。")]),_._v(" "),e("p",[_._v("总的来说，这些会话复用的技术在保证"),e("code",[_._v("1-RTT")]),_._v("的同时，也节省了生成会话密钥这些算法所消耗的时间，是一笔可观的性能提升。")]),_._v(" "),e("h3",{attrs:{id:"psk"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#psk"}},[_._v("#")]),_._v(" PSK")]),_._v(" "),e("p",[_._v("刚刚说的都是"),e("code",[_._v("1-RTT")]),_._v("情况下的优化，那能不能优化到"),e("code",[_._v("0-RTT")]),_._v("呢？")]),_._v(" "),e("p",[_._v("答案是可以的。做法其实也很简单，在发送"),e("strong",[_._v("Session Ticket")]),_._v("的同时带上应用数据，不用等到服务端确认，这种方式被称为"),e("code",[_._v("Pre-Shared Key")]),_._v("，即 PSK。")]),_._v(" "),e("p",[_._v("这种方式虽然方便，但也带来了安全问题。中间人截获"),e("code",[_._v("PSK")]),_._v("的数据，不断向服务器重复发，类似于 TCP 第一次握手携带数据，增加了服务器被攻击的风险。")]),_._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("对称加密：指的是"),e("code",[_._v("加密")]),_._v("和"),e("code",[_._v("解密")]),_._v("用的是"),e("strong",[_._v("同样的密钥")]),_._v("。")])]),_._v(" "),e("li",[e("p",[_._v("非对称加密：如果有 A、 B 两把密钥，如果用 A 加密过的数据包只能用 B 解密；反之，如果用 B 加密过的数据包只能用 A 解密。")])]),_._v(" "),e("li",[e("p",[_._v("传统 RSA 握手过程：")]),_._v(" "),e("ul",[e("li",[_._v("C 发送 C_random 和加密方法列表")]),_._v(" "),e("li",[_._v("S 发送 S_random、选的加密方法、公钥")]),_._v(" "),e("li",[_._v("C 生成随机数 pre_random，用公钥加密，传给 S")]),_._v(" "),e("li",[_._v("S 用私钥解密得到 pre_random")]),_._v(" "),e("li",[_._v("通信双方都有 C_random、S_random、pre_random 这三样凭证，用（约定的对称加密方法）RSA 算法混合，生成秘钥")]),_._v(" "),e("li",[_._v("使用这个秘钥开始通信即可，哪怕中间人截获秘钥也无法得知 pre_random (自始至终都在 S 端)")])])]),_._v(" "),e("li",[e("p",[_._v("TLS1.2 握手中，使用"),e("code",[_._v("ECDHE")]),_._v("实现"),e("code",[_._v("pre_random")]),_._v("的加密解密，客户端生成"),e("code",[_._v("secret")]),_._v("后，会给服务端发送一个收尾的消息，发送完收尾消息后可以提前"),e("code",[_._v("抢跑")]),_._v("，直接发送 HTTP 报文，节省了一个 RTT。")])]),_._v(" "),e("li",[e("p",[_._v("TLS1.3 在 TLS1.2 的基础上废除了大量的算法，提升了安全性。同时利用会话复用节省了重新生成密钥的时间，利用 PSK 做到了"),e("code",[_._v("0-RTT")]),_._v("连接。")])])]),_._v(" "),e("h2",{attrs:{id:"感谢巨人"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#感谢巨人"}},[_._v("#")]),_._v(" 感谢巨人")]),_._v(" "),e("ol",[e("li",[e("a",{attrs:{href:"https://sanyuan0704.top/blogs/browser/browser-security/003.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("HTTPS 为什么让数据传输更安全"),e("OutboundLink")],1)]),_._v(" "),e("li",[e("a",{attrs:{href:"https://sanyuan0704.top/blogs/net/http/015.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("TLS 1.2 握手的过程是怎样的"),e("OutboundLink")],1)]),_._v(" "),e("li",[e("a",{attrs:{href:"https://sanyuan0704.top/blogs/net/http/016.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("TLS 1.3 做了哪些改进"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=t.exports}}]);