(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{622:function(t,s,a){"use strict";a.r(s);var n=a(13),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"javascript-编程基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-编程基础"}},[t._v("#")]),t._v(" JavaScript 编程基础")]),t._v(" "),a("h2",{attrs:{id:"js-的内存分为栈、堆、池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-的内存分为栈、堆、池"}},[t._v("#")]),t._v(" JS 的内存分为栈、堆、池")]),t._v(" "),a("p",[t._v("其中栈存放"),a("strong",[t._v("变量")]),t._v("，堆存放"),a("strong",[t._v("对象")]),t._v("，池存放"),a("strong",[t._v("常量")]),t._v("，所以也叫常量池")]),t._v(" "),a("h2",{attrs:{id:"栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),a("p",[t._v("栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈是一种"),a("strong",[t._v("先进后出")]),t._v("的结构，为了获得栈底的元素，必须拿掉上面的元素。")]),t._v(" "),a("h2",{attrs:{id:"堆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[t._v("#")]),t._v(" 堆")]),t._v(" "),a("p",[t._v("一种排序过的树状结构，我们说的堆，通常指二叉堆，必须是完全二叉树(近似满二叉树)。堆的特点是根节点值是整个树中的最值（大顶堆/小顶堆）")]),t._v(" "),a("p",[t._v("堆经常被用来实现优先队列，这种结构优势是可以动态分配内存大小，缺点是运行时需动态分配内存，存取速度较慢")]),t._v(" "),a("h2",{attrs:{id:"数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),a("h3",{attrs:{id:"基本数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本数据类型"}},[t._v("#")]),t._v(" 基本数据类型")]),t._v(" "),a("p",[t._v("String、Number、Boolean、null、undefined、Symbol")]),t._v(" "),a("p",[t._v("保存在栈内存中，因为占用空间小、大小固定，频繁被使用")]),t._v(" "),a("ul",[a("li",[t._v("产生闭包的变量会被存放在堆中，因为栈在上下文执行完毕后会被 GC，堆不会。")]),t._v(" "),a("li",[t._v("由 JS 引擎"),a("strong",[t._v("逃逸分析")]),t._v("出变量应该存在哪种结构中。")])]),t._v(" "),a("h3",{attrs:{id:"引用数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用数据类型"}},[t._v("#")]),t._v(" 引用数据类型")]),t._v(" "),a("p",[t._v("Object、Array、Function...")]),t._v(" "),a("p",[t._v("存储在堆内存")]),t._v(" "),a("ul",[a("li",[t._v("占据空间大、大小不确定")]),t._v(" "),a("li",[t._v("引用数据类型在栈中存储了指针，指向堆内该实体的起始地址")]),t._v(" "),a("li",[t._v("Js 解释器寻找引用值时，会先检索栈中的地址，再获得堆中的实体")])]),t._v(" "),a("h3",{attrs:{id:"nan-not-a-number"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nan-not-a-number"}},[t._v("#")]),t._v(" NaN（Not-A-Number）")]),t._v(" "),a("p",[t._v("NaN 是一个 value, 这个 value 的 type 是 number。")]),t._v(" "),a("p",[t._v("但是跟普通的 type 是 number 的 value 不一样的是，NaN 代表 'Not a number' 这一意义。")]),t._v(" "),a("h4",{attrs:{id:"isnan"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isnan"}},[t._v("#")]),t._v(" isNaN()")]),t._v(" "),a("p",[t._v("只要不是 number 就会返回 true。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNaN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'A String'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNaN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNaN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),a("h4",{attrs:{id:"number-isnan"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#number-isnan"}},[t._v("#")]),t._v(" Number.isNaN()")]),t._v(" "),a("p",[t._v("只有 Number.isNaN(NaN)返回 true。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("Number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNaN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("NaN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n\nNumber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNaN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'A String'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n\nNumber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNaN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n\nNumber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNaN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n")])])]),a("h2",{attrs:{id:"变量赋值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量赋值"}},[t._v("#")]),t._v(" 变量赋值")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("基本数据类型直接拷贝一份")])]),t._v(" "),a("li",[a("p",[t._v("引用数据类型相当于多了一个地址指针，实际指向同一个对象")])])]),t._v(" "),a("h2",{attrs:{id:"js-创建对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-创建对象"}},[t._v("#")]),t._v(" Js 创建对象")]),t._v(" "),a("ul",[a("li",[t._v("new 关键字执行构造函数")]),t._v(" "),a("li",[t._v("对象字面量")])]),t._v(" "),a("h3",{attrs:{id:"new-关键字做了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-关键字做了什么"}},[t._v("#")]),t._v(" new 关键字做了什么")]),t._v(" "),a("ul",[a("li",[t._v("在内存中创建一个空对象")]),t._v(" "),a("li",[t._v("类的 prototype 赋值给对象内部的 prototype")]),t._v(" "),a("li",[t._v("构造函数内的 this 被指向创建出来的新对象")]),t._v(" "),a("li",[t._v("执行构造函数的内部代码")]),t._v(" "),a("li",[t._v("如果构造函数没有返回对象，则默认返回创建出来的新对象")])]),t._v(" "),a("h2",{attrs:{id:"this-绑定的优先级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this-绑定的优先级"}},[t._v("#")]),t._v(" this 绑定的优先级")]),t._v(" "),a("p",[t._v("由高到低：")]),t._v(" "),a("ul",[a("li",[t._v("new 绑定")]),t._v(" "),a("li",[t._v("显式绑定(call(obj, args1, arg2...)、apply(obj, [args])、bind(obj, arg1, arg2, ...)非立即执行)")]),t._v(" "),a("li",[t._v("隐式绑定(由对象发起的调用)")]),t._v(" "),a("li",[t._v("默认绑定(独立函数调用)")])]),t._v(" "),a("h2",{attrs:{id:"js-作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-作用域"}},[t._v("#")]),t._v(" Js 作用域")]),t._v(" "),a("h3",{attrs:{id:"作用域不等于执行上下文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域不等于执行上下文"}},[t._v("#")]),t._v(" 作用域不等于执行上下文")]),t._v(" "),a("p",[t._v("JavaScript 属于解释型语言，他的执行分为解释和执行两个阶段")]),t._v(" "),a("p",[a("strong",[t._v("解释阶段")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("词法分析")]),t._v(" "),a("li",[t._v("语法分析")]),t._v(" "),a("li",[t._v("作用域规则确定")])]),t._v(" "),a("p",[a("strong",[t._v("执行阶段")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("创建执行上下文")]),t._v(" "),a("li",[t._v("执行函数")]),t._v(" "),a("li",[t._v("垃圾回收")])]),t._v(" "),a("blockquote",[a("p",[t._v("JavaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。")])]),t._v(" "),a("p",[t._v("作用域和执行上下文之间最大的区别是： "),a("strong",[t._v("执行上下文(EC)在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变")]),t._v("。")]),t._v(" "),a("p",[t._v("一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。"),a("strong",[t._v("同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值")]),t._v("。")]),t._v(" "),a("p",[t._v("作用域决定了代码块中变量和方法的可见性。")]),t._v(" "),a("h3",{attrs:{id:"作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),a("p",[t._v("当前作用域下没有定义的变量，变成自由变量。自由变量会到父级作用域（*实际上是自由变量"),a("strong",[t._v("所在的函数")]),t._v("被"),a("strong",[t._v("创建")]),t._v("时的作用域中)查找，一层一层向上，直到找到全局作用域还是没找到，就宣布放弃(undefined)。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("show")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//10，而不是20")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("show")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h3",{attrs:{id:"全局作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局作用域"}},[t._v("#")]),t._v(" 全局作用域")]),t._v(" "),a("h4",{attrs:{id:"初始化全局对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始化全局对象"}},[t._v("#")]),t._v(" 初始化全局对象")]),t._v(" "),a("ul",[a("li",[t._v("js 引擎在执行代码之前，会在堆内存中创建一个全局对象，Global Object(GO)")]),t._v(" "),a("li",[a("strong",[t._v("所有作用域")]),t._v(" 都可以访问该对象")]),t._v(" "),a("li",[t._v("里面会自带一些工具函数，date、setTimeout、Infinity 等等")]),t._v(" "),a("li",[t._v("包含一个指向自己的 window 属性")])]),t._v(" "),a("h4",{attrs:{id:"执行上下文栈-ecs-调用栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文栈-ecs-调用栈"}},[t._v("#")]),t._v(" 执行上下文栈 ECS(调用栈)")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("js 引擎内部有一个 ECS，用于执行代码的调用栈。全局 EC 中，变量对象(VO)就是 GO")])]),t._v(" "),a("li",[a("p",[t._v("全局的代码会先构建一个全局执行上下文(GEC)")])]),t._v(" "),a("li",[a("p",[t._v("GEC 会被压入 ECS 中执行")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("步骤一：parse 转换成 AST 的过程中，将全局定义的变量、函数加到 GO 中，但是不会赋值。")]),t._v(" "),a("p",[t._v("这就是变量的作用域提升")])]),t._v(" "),a("li",[a("p",[t._v("步骤二：在代码的执行过程中，该赋值的赋值，该执行的执行")])])])])]),t._v(" "),a("h3",{attrs:{id:"函数作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数作用域"}},[t._v("#")]),t._v(" 函数作用域")]),t._v(" "),a("p",[t._v("在执行一个函数时，会根据函数体创建一个函数执行上下文(FEC)，压入 ECS。包含以下三部分")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在解析成 AST 时，会创建活跃对象(AO)")]),t._v(" "),a("p",[t._v("AO 中包含形参、arguments、函数定义和指向函数的对象、变量")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("作用域链")]),t._v(":由 VO(在函数中就是 AO 对象)和父级 VO 组成，一层一层向外查找")])])]),t._v(" "),a("h3",{attrs:{id:"块级作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#块级作用域"}},[t._v("#")]),t._v(" 块级作用域")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("ES5 中只有函数作用域、全局作用域。实际上 ES6 之后出现了块级作用域，可用 let、const 生成。而且前面提到的变量对象 VO 改名了，现在叫变量环境 VE")])]),t._v(" "),a("li",[a("p",[t._v("两种创建方式")]),t._v(" "),a("ul",[a("li",[t._v("在一个函数内部，function、箭头函数")]),t._v(" "),a("li",[t._v("在一个花括号内部")])])]),t._v(" "),a("li",[a("p",[t._v("块级作用域中声明变量不会提升到代码块顶部")])]),t._v(" "),a("li",[a("p",[t._v("禁止重复声明")])]),t._v(" "),a("li",[a("p",[t._v("避免了 for 循环中使用延时函数产生闭包导致的 bug，绑定块级作用域形成父子作用域解决")])])]),t._v(" "),a("h2",{attrs:{id:"云谦讲解的-js-基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#云谦讲解的-js-基础"}},[t._v("#")]),t._v(" 云谦讲解的 JS 基础")]),t._v(" "),a("h3",{attrs:{id:"🐍-作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🐍-作用域"}},[t._v("#")]),t._v(" 🐍 作用域")]),t._v(" "),a("p",[t._v("作用域决定执行代码时的上下文，包括可以访问哪些变量、函数、对象等。")]),t._v(" "),a("p",[t._v("通常大家会接触到的有全局作用域、函数作用域、块级作用域、词法作用域、作用域链。")]),t._v(" "),a("p",[t._v("全局作用域只有一个，就是定义在最外面的那个。")]),t._v(" "),a("p",[t._v("函数会创建新的作用域，即函数作用域，每次执行函数，都会创建新的作用域。")]),t._v(" "),a("p",[t._v("函数作用域会在函数执行时被绑定到函数执行时的上下文。函数作用域里的变量只能在函数体内被访问到。")]),t._v(" "),a("p",[t._v("if、switch、while、for 等语句会创建块级作用域。")]),t._v(" "),a("p",[t._v("那块级作用域里的变量能在外部被访问吗？")]),t._v(" "),a("p",[t._v("这要看是用 var 还是 let/const 了。var 是函数作用域级，而 let 和 const 是块级作用域级。")]),t._v(" "),a("p",[t._v("JavaScirpt 处理作用域的方式是词法作用域，也叫静态作用域，与之相对的是动态作用域，很少有语言用，比如 Bash 就是动态作用域。")]),t._v(" "),a("p",[t._v("词法作用域决定了作用域在代码被 JavaScript 引擎编译时即会决定，而不是在代码被运行时决定。")]),t._v(" "),a("p",[t._v("最后，作用域链是什么？")]),t._v(" "),a("p",[t._v("执行上下文会为每个词法环境创建指向父作用域的引用，所以往里的作用域就能访问往外的作用域，而外面的不能访问里面的。")]),t._v(" "),a("h3",{attrs:{id:"🐹-闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🐹-闭包"}},[t._v("#")]),t._v(" 🐹 闭包")]),t._v(" "),a("p",[t._v("理解了作用域，闭包就很好理解了。")]),t._v(" "),a("p",[t._v("闭包是指嵌套函数里，子函数能访问父函数的作用域，就算父函数已经完成执行。")]),t._v(" "),a("p",[t._v("原因是子函数的执行上下文创建了指向父函数作用域的引用，所以子函数没结束，引用一直存在，父函数的作用域就一直存在。")]),t._v(" "),a("h3",{attrs:{id:"🐢-hoist-提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🐢-hoist-提升"}},[t._v("#")]),t._v(" 🐢 Hoist-提升")]),t._v(" "),a("p",[t._v("作用域内的变量和函数会在编译阶段被放到内存里的过程叫 Hoist。")]),t._v(" "),a("p",[t._v("有个误解是大家认为 Hoist 是把他们提到作用域的前面，但其实并不是，var、let、const、function 都会被 hoist，只是有些不会被初始化，所以提前使用会报 ReferenceError。")]),t._v(" "),a("p",[t._v("var 会被初始化为 undefined，传统的函数定义 functon foo() {} 会被初始化，let 和 const 不会被初始化。")]),t._v(" "),a("p",[t._v("所以 var 定义的变量可以提前使用，但值是 undefined，传统函数定义可以正常提前使用，let 和 const 提前使用会报错。")]),t._v(" "),a("p",[t._v("注意，函数也可通过 var、let、const 的方式定义。")]),t._v(" "),a("p",[t._v("case 如下：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("foo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\na"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// undefined")]),t._v("\nb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Reference Error")]),t._v("\nc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Reference Error")]),t._v("\nd"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// function d() {}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("d")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"🦀-this-关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🦀-this-关键字"}},[t._v("#")]),t._v(" 🦀 this 关键字")]),t._v(" "),a("p",[t._v("一句话概括：this 的指向是由所在函数的调用方式决定的。")]),t._v(" "),a("p",[t._v("函数被调用时，会创建执行上下文，这个上下文中存了很多信息，比如函数从哪里被调用、传入的参数等。")]),t._v(" "),a("p",[t._v("其中 this 关键字就是用来保存函数从哪里来。")]),t._v(" "),a("p",[t._v("不同场景下 this 的指向是不同的，并且 this 可以被修改，这些规则要吃透需要稍微花的时间，以下是我之前整理的题，大家可以试试。")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("函数被正常执行时 foo()，this 指向啥？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("globalThis\n")])])])]),t._v(" "),a("li",[a("p",[t._v("箭头函数的 this 指向啥？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("父作用域。\n箭头函数没有原型，访问this会得到就近外层函数的this。\n")])])])]),t._v(" "),a("li",[a("p",[t._v("this 可通过哪些方式被修改？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("3种： bind、call、apply。\n其中的优先级：\nnew绑定 > 显示绑定(apply/call/bind) > 隐式绑定(obj.foo()) > 默认绑定(独立函数调用)。\n")])])])]),t._v(" "),a("li",[a("p",[t._v("箭头函数的 this 可被修改吗？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("不可。\n箭头函数获得的this在运行时被确定，不能修改。因为本身没有可绑定的 this。\n")])])])]),t._v(" "),a("li",[a("p",[t._v("class 箭头函数定义的方法 this 指向啥？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("实例对象。\nclass中的方法如果是普通函数方法，该方法会绑定在构造函数的原型上。\n但是如果方式是箭头函数方法，该方法会绑定在构造函数上。\n通过上述方式调用class中的方法，无论是箭头函数方法还是普通函数方法，方法中的this都指向实例对象。\n")])])]),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6923086072855396366",target:"_blank",rel:"noopener noreferrer"}},[t._v("class 中的箭头函数和普通函数的 this 指向"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[t._v("bind 过的函数，还可通过 call 和 apply 修改 this 吗？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("不可。\n")])])])]),t._v(" "),a("li",[a("p",[t._v("函数作为对象成员调用时，比如 foo 对象中的 bar 方法 foo.bar() 中的 this 指向啥？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("foo对象自己。\n")])])])]),t._v(" "),a("li",[a("p",[t._v("函数或其父作用域为严格模式时，this 指向啥？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("undefined。\n在严格模式下，\n全局作用域中的this指向window对象。\n全局作用域中的函数中的this等于undefined。\n对象的函数中的this指向调用函数的对象实例。\n构造函数中的this指向构造函数创建的对象实例。\n在事件处理函数中，this指向触发事件的目标对象。\n")])])])])])])}),[],!1,null,null,null);s.default=r.exports}}]);